using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using Newtonsoft.Json;

namespace TokappAPIClient
{
    /// <summary>
    /// Client wrapper for TokApp API.
    /// </summary>
    public class Client
    {
        private string _host;
        private string _key;

        /// <summary>
        /// Creates a new instance.
        /// </summary>
        /// <param name="_host">URL to service host</param>
        /// <param name="_key">Api key.</param>
        public Client(string _host, string _key)
        {
            this._host = _host;
            this._key = _key;
        }

        /// <summary>
        /// Executes <c>status</c> command.
        /// </summary>
        /// <returns>Data returned.</returns>
        public StatusResponse CheckStatus()
        {
            ResponseBase response = this.makePetition("status");
            return StatusResponse.CreateInstance(response);
        }


        /// <summary>
        /// Gets TokApp user-names of one or more contacts from their phone number or email.
        /// </summary>
        /// <param name="phones">Array with phone numbers to check.</param>
        /// <param name="emails">Array with emails to check.</param>
        /// <returns></returns>
        public GetContactsResponse[] GetContacts(string[] phones, string[] emails)
        {
            var data = new Dictionary<string, object>();
            data.Add("phones", phones);
            data.Add("emails", emails);
            ResponseBase response = this.makePetition("getcontacts", data);
            return GetContactsResponse.CreateArray(response);
        }

        /// <summary>
        /// Sends one or more messages to one or more contacts.
        /// </summary>
        /// <param name="messages">Array with each message data. See documentation for further information.</param>
        /// <returns>Global delivery identifier. This ID is generated by the system when delivery is sent and will allow to client identifying it to query it's status later with the getdeliverystatus command. The message delivery will be performed in background to avoid client waiting for process to end. This field allows querying later it's status.</returns>
        public string Send(dynamic[] messages)
        {
            ResponseBase result = this.makePetition("send", messages);
            return result.data.id;
        }

        /// <summary>
        /// Queries a delivery status.
        /// </summary>
        /// <param name="id">Delivery identifier returned previously by send command.</param>
        /// <returns>Instance with data returned.</returns>
        public GetDeliveryStatusResponse GetDeliveryStatus(string id)
        {
            var data = new Dictionary<string, string>();
            data.Add("id", id);
            ResponseBase response = this.makePetition("getdeliverystatus", data);
            return GetDeliveryStatusResponse.CreateInstance(response);
        }

        /// <summary>
        /// Queries incoming messages received.
        /// </summary>
        /// <returns>Array with received messages.</returns>
        public GetMessagesResponse[] GetMessages()
        {
            ResponseBase response = this.makePetition("getmessages");
            return GetMessagesResponse.CreateArray(response);
        }

        /// <summary>
        /// Sets a image file as sender's logo
        /// </summary>
        /// <param name="pathToFile">Complete path to image file.</param>
        public void SetLogo(string pathToFile)
        {
            ResponseBase response = makePetition("setlogo", null, pathToFile);
        }

        /// <summary>
        /// Sets the sender's name.
        /// </summary>
        /// <param name="name">New name to set.</param>
        public void SetName(string name)
        {
            var data = new Dictionary<string, string>();
            data.Add("name", name);
            ResponseBase response = makePetition("setname", data);
        }

        #region Private methods

        /// <summary>
        /// Makes a petition to server and returns result or throws an exception.
        /// </summary>
        /// <param name="command">Command to execute.</param>
        /// <param name="data">Data to send as command params.</param>
        /// <param name="file">Complete path to file to upload with petition.</param>
        /// <returns>Response object.</returns>
        private ResponseBase makePetition(string command, object data, string file)
        {
            Dictionary<string, object> param = buildParameters(command, data);

            validateFile(file);

            var http = (HttpWebRequest)WebRequest.Create(new Uri(_host));
            prepareRequest(file, param, http);

            WebResponse response = null;
            try
            {
                response = http.GetResponse();
            }
            catch (Exception e)
            {
                if (e is WebException && ((WebException)e).Status == WebExceptionStatus.ProtocolError)
                {
                    WebResponse errResp = ((WebException)e).Response;
                    string error = string.Empty;
                    error = extractErrorFromWebException(errResp);
                    throw new Exception(error);
                }
            }

            var stream = response.GetResponseStream();
            var sr = new StreamReader(stream);
            var content = sr.ReadToEnd();

            ResponseBase resp = JsonConvert.DeserializeObject<ResponseBase>(content);
            if (resp.result != 0)
            {
                throw new Exception(string.Concat("Command returned error code ", resp.result, "; ", resp.message));
            }

            return resp;
        }

        /// <summary>
        /// Extracts the details from a WebException.
        /// </summary>
        /// <param name="errResp">Instance of response contained in WebException.</param>
        /// <returns>Exception message.</returns>
        private static string extractErrorFromWebException(WebResponse errResp)
        {
            string error = string.Empty;
            using (Stream respStream = errResp.GetResponseStream())
            {
                byte[] respByte = new byte[4096];
                int bytesLeidos = 0;
                while ((bytesLeidos = respStream.Read(respByte, 0, respByte.Length)) != 0)
                {
                    error = string.Concat(error, Encoding.UTF8.GetString(respByte, 0, bytesLeidos));
                }
            }

            return error;
        }

        /// <summary>
        /// Prepares the request to send to server.
        /// </summary>
        /// <param name="file">path to the file to upload or null if no file will be uploaded.</param>
        /// <param name="param">Dictionary of parameters to send.</param>
        /// <param name="http">Instance of request.</param>
        private static void prepareRequest(string file, Dictionary<string, object> param, HttpWebRequest http)
        {
            string paramsTemplate;
            string fileTemplate;
            byte[] boundarybytes = null;
            string fields = string.Empty;
            FileStream fileStream = null;
            byte[] bytesFileTemplate = null;
            if (string.IsNullOrWhiteSpace(file))
            {
                http.Accept = "application/json";
                http.ContentType = "application/json";
                paramsTemplate = "{0}";
                fileTemplate = null;
                var parsedContent = JsonConvert.SerializeObject(param);
                fields = string.Format(paramsTemplate, parsedContent);
            }
            else
            {
                http.Accept = "application/json; */*";
                string boundary = "---------------------------" + DateTime.Now.Ticks.ToString("x");
                boundarybytes = Encoding.UTF8.GetBytes(string.Concat("\r\n--", boundary, "\r\n"));
                http.ContentType = "multipart/form-data; boundary=" + boundary;
                paramsTemplate = string.Concat("\r\n--", boundary, "\r\n", "Content-Disposition: form-data; name=\"{0}\" Content-Type: application/json; \r\n\r\n{1}");
                fileTemplate = string.Concat("\r\n--", boundary, "\r\n", "Content-Disposition: form-data; Content-Type: image/jpg; name=\"file\"; filename=\"{0}\"\r\n\r\n");
                foreach (string key in param.Keys)
                {
                    fields = string.Concat(fields, string.Format(paramsTemplate, key, param[key].ToString()));
                }
                fileStream = new FileStream(file, FileMode.Open, FileAccess.Read);
                bytesFileTemplate = Encoding.UTF8.GetBytes(string.Format(fileTemplate, Path.GetFileName(file)));
            }
            http.Method = "POST";
            http.KeepAlive = true;

            byte[] bytes = Encoding.UTF8.GetBytes(fields);

            Stream newStream = http.GetRequestStream();
            newStream.Write(bytes, 0, bytes.Length);

            if (fileTemplate != null)
            {
                newStream.Write(bytesFileTemplate, 0, bytesFileTemplate.Length);

                bytes = new byte[4096];
                int bytesRead = 0;
                while ((bytesRead = fileStream.Read(bytes, 0, bytes.Length)) != 0)
                {
                    newStream.Write(bytes, 0, bytesRead);
                }
                newStream.Write(boundarybytes, 0, boundarybytes.Length);
            }

            newStream.Close();
        }

        /// <summary>
        /// Validates a file's path.
        /// </summary>
        /// <param name="file">Complete path to validate.</param>
        private static void validateFile(string file)
        {
            if (!string.IsNullOrWhiteSpace(file))
            {
                if (!File.Exists(file))
                {
                    throw new ArgumentException("file: File does not exists.");
                }
            }
        }

        /// <summary>
        /// Builds the dictionary of parameters to send.
        /// </summary>
        /// <param name="command">Command</param>
        /// <param name="data">Dictionary of data to append to request.</param>
        /// <returns>Dictionary of parameters to send.</returns>
        private Dictionary<string, object> buildParameters(string command, object data)
        {
            var param = new Dictionary<string, object>();
            param.Add("key", _key);
            param.Add("command", command);
            if (data != null)
            {
                param.Add("data", data);
            }

            return param;
        }

        /// <summary>
        /// Makes a petition to server and returns result or throws an exception.
        /// </summary>
        /// <param name="command">Command to execute.</param>
        /// <param name="data">Data to send as command params.</param>
        /// <returns>Response object.</returns>
        private ResponseBase makePetition(string command, object data)
        {
            return makePetition(command, data, null);
        }

        /// <summary>
        /// Makes a petition to server and returns result or throws an exception.
        /// </summary>
        /// <param name="command">Command to execute.</param>
        /// <returns>Response object.</returns>
        private ResponseBase makePetition(string command)
        {
            return makePetition(command, null);
        }

#endregion
    }
}
